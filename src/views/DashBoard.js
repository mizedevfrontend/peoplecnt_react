import React, { useState, useRef, useEffect } from "react";
import IonIcon from "../components/IonIcon";
//import cctvSample from "../images/cctv_sample01.jpg";
import t300 from "../images/gm-t300.png";
import logo from "../images/logo.png";
import "../styles/dashboard.css";
import CustomIcon from "../components/CustomIcon";
import apiClient from "../apiClient";
import { useNavigate } from "react-router-dom";

const CHUNK_SIZE = 3; // Ìïú columnÏóê 3Ï§Ñ

function chunkArray(arr, size) {
  const res = [];
  for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
  return res;
}

const DashBoard = () => {
  useEffect(() => {
    if (!sessionStorage.getItem("hasReloaded")) {
      sessionStorage.setItem("hasReloaded", "true");
      window.location.reload();
    }
  }, []);

  const selectedWorkplaceId = localStorage.getItem("selectedWorkplaceId"); //useWorkplace(); // Context ÏÇ¨Ïö©

  const [now, setNow] = useState(new Date());
  const [groups, setGroups] = useState([]);
  const [stayCnt, setStayCnt] = useState([]);
  const [authResults, setAuthResults] = useState([]); // Ïù∏Ï¶ùÎ°úÍ∑∏ Îç∞Ïù¥ÌÑ∞
  const [cameraList, setCameraLists] = useState([]);
  const navigate = useNavigate();

  useEffect(() => {
    const id = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(id);
  }, []);

  const pollRef = useRef(null);

  useEffect(() => {
    if (!selectedWorkplaceId) return;

    fetchCameras();
    const camTimer = setInterval(fetchCameras, 10000);
    return () => clearInterval(camTimer);
  }, [selectedWorkplaceId]);

  useEffect(() => {
    if (!selectedWorkplaceId) return;

    const fetchAll = async () => {
      // Í∑∏Î£πÎ≥Ñ Ï∂úÏûÖÌòÑÌô© count API Ìò∏Ï∂ú
      try {
        const { data } = await apiClient.post(
          "/api/DashBoard/all-entryexit-group-count-list",
          {
            Page: 1,
            PageSize: 100,
            OrderType: 1,
            WorkplaceId: selectedWorkplaceId,
            LoginUserId: localStorage.getItem("userid"),
            YearMonthDay: now.toISOString().slice(0, 10),
          }
        );

        const res = typeof data === "string" ? JSON.parse(data) : data;
        setGroups(
          Array.isArray(res.data)
            ? res.data.map((g) => ({
                name: g.groupName,
                count: g.groupCnt ?? g.groupCount ?? 0,
              }))
            : []
        );
      } catch (e) {
        console.error("Dashboard group count error", e);
      }

      // ÏûîÎ•ò Ï∂úÏûÖÌòÑÌô© count API Ìò∏Ï∂ú
      try {
        const { data } = await apiClient.post(
          "/api/DashBoard/all-entryexit-remain-count-list",
          {
            Page: 1,
            PageSize: 100,
            OrderType: 1,
            WorkplaceId: selectedWorkplaceId,
            LoginUserId: localStorage.getItem("userid"),
            YearMonthDay: now.toISOString().slice(0, 10),
          }
        );

        const stayRes = typeof data === "string" ? JSON.parse(data) : data;

        setStayCnt(
          Array.isArray(stayRes.data)
            ? stayRes.data.map((g) => ({
                recount: g.remainCount,
              }))
            : []
        );
      } catch (e) {
        console.error("Dashboard remain count error", e);
      }

      // Ï∂úÏûÖÎÇ¥Ïó≠ Î°úÍ∑∏
      try {
        const response = await apiClient.post(
          "/api/EntryExit/all-log-data-list",
          {
            Page: 1,
            PageSize: 100,
            OrderType: "eventtime_desc",
            WorkplaceId: selectedWorkplaceId,
            StartDate: now.toISOString().slice(0, 10),
            EndDate: now.toISOString().slice(0, 10),
            GroupId: "",
            AuthType: "",
            AuthResult: "",
            CompanyTxt: "",
            EmployeeName: "",
            LoginUserId: localStorage.getItem("userid"),
          }
        );

        const responseData =
          typeof response.data === "string"
            ? JSON.parse(response.data)
            : response.data;

        console.log(response.data);

        if (response.data) {
          const processedResults = responseData.data.map((item) => ({
            date: item.eventTime,
            category: item.groupName,
            department: item.companyName,
            rank: item.userTitle,
            name: item.userName,
            phone: item.phone,
            device: item.deviceName,
            method: item.authType,
            result: item.eventDesc,
            imgFolderName: item.imgFolderName,
            imgFileName: item.imgFileName,
          }));
          setAuthResults(processedResults);
        } else {
          setAuthResults([]);
        }
      } catch (e) {
        console.error("Dashboard EntryExit log error", e);
      }
    };

    fetchAll();
    pollRef.current = setInterval(fetchAll, 1000);

    return () => {
      clearInterval(pollRef.current);
    };
  }, [selectedWorkplaceId, now]);

  const handleClose = () => {
    navigate(-1); // Î∏åÎùºÏö∞Ï†Ä ÌûàÏä§ÌÜ†Î¶¨ Í∏∞Ï§ÄÏúºÎ°ú Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
  };

  const fDate = now.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
  const fTime = now.toLocaleTimeString("ko-KR", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const columns = chunkArray(groups, CHUNK_SIZE);
  const totalVisit = groups.reduce((acc, g) => acc + Number(g.count), 0);
  const totalStay = stayCnt.reduce((acc, g) => acc + Number(g.recount), 0);

  const ROW_LIMIT = 5;
  const rows = [
    ...authResults.slice(0, ROW_LIMIT),
    ...Array(Math.max(0, ROW_LIMIT - authResults.length)).fill(null),
  ];

  const fetchCameras = async () => {
    // Ïã§ÏãúÍ∞Ñ Ïπ¥Î©îÎùºÎ¶¨Ïä§Ìä∏ ÎøåÎ¶¨Í∏∞
    try {
      const response = await apiClient.post(
        "/api/RealTimeVideo/all-camera-list",
        {
          Page: 1,
          PageSize: 100,
          OrderType: 1,
          WorkplaceId: selectedWorkplaceId,
          LoginUserId: localStorage.getItem("userid"),
        }
      );

      const responseData =
        typeof response.data === "string"
          ? JSON.parse(response.data)
          : response.data;

      if (!responseData || !responseData.data) {
        console.warn("‚ùå No camera data found.");
        setCameraLists([]);
        return;
      }

      console.log("üì∑ Ïπ¥Î©îÎùº Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏", response.data);

      const categories = responseData.data.map((item) => ({
        cameraID: item.camId,
        cameraName: item.camPosition,
        camUrl: item.camURL,
        serverIP: item.serverIP,
        camUUID: item.camUUID,
      }));

      setCameraLists(categories);

      setTimeout(() => {
        categories.forEach((camera, index) => {
          console.log(`üì° WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ: index ${index}`);
          startPlay(index, camera.serverIP, camera.camUUID);
        });
      }, 500); // Ï¥àÍ∏∞Ìôî ÏßÄÏó∞ Î∞©ÏßÄ
    } catch (error) {
      console.error("üö® Failed to fetch camera lists:", error);
    }
  };

  const RECONNECT_INTERVAL = 300000; // 5Î∂ÑÎßàÎã§ ÏûêÎèô Ïû¨Ïó∞Í≤∞
  const MAX_SESSION_DURATION = 600000; // 10Î∂ÑÎßàÎã§ Í∞ïÏ†ú Ïû¨Ïó∞Í≤∞
  const MAX_CONNECTIONS = 20; // ÏµúÎåÄ WebSocket Í∞úÏàò Ï†úÌïú

  let reconnectTimers = {};
  let pendingBuffers = {};
  let isBufferProcessing = {};

  const startPlay = (index, serverIP, camUUID) => {
    const videoEl = document.getElementById(`mse-video-${index}`);
    if (!videoEl) {
      console.warn(`üö® Video element not found for index ${index}`);
      return;
    }

    if (
      window[`ws_${index}`] &&
      window[`ws_${index}`].readyState === WebSocket.OPEN
    ) {
      console.warn(`‚ö†Ô∏è WebSocket already open for index ${index}`);
      return;
    }

    const mse = new MediaSource();
    videoEl.src = URL.createObjectURL(mse);

    const useWS = serverIP.includes("192.168.0.2");
    const protocol = useWS ? "ws" : "wss";

    const wsUrl = `${protocol}://${serverIP}/stream/${camUUID}/channel/0/mse?uuid=${camUUID}&channel=0`;

    if (window[`ws_${index}`]) {
      console.warn(`‚ùå Closing existing WebSocket for index ${index}`);
      window[`ws_${index}`].close();
      delete window[`ws_${index}`];
    }

    let ws = new WebSocket(wsUrl);
    window[`ws_${index}`] = ws;
    ws.binaryType = "arraybuffer";

    let mseSourceBuffer = null;
    pendingBuffers[index] = [];
    isBufferProcessing[index] = false;

    ws.onopen = () => {
      console.log(`‚úÖ WebSocket connected: ${wsUrl}`);

      if (reconnectTimers[index]) clearTimeout(reconnectTimers[index]);
      reconnectTimers[index] = setTimeout(() => {
        console.log(`üîÑ WebSocket ÏûêÎèô Ïû¨Ïó∞Í≤∞ (index: ${index})`);
        stopStreamAsync(index).then(() => startPlay(index, serverIP, camUUID));
      }, RECONNECT_INTERVAL);
    };

    ws.onmessage = (event) => {
      pendingBuffers[index].push(event.data);

      if (!isBufferProcessing[index]) {
        isBufferProcessing[index] = true;
        setTimeout(() => {
          while (
            pendingBuffers[index].length > 0 &&
            !mseSourceBuffer?.updating
          ) {
            try {
              mseSourceBuffer.appendBuffer(pendingBuffers[index].shift());
            } catch (error) {
              console.error("üö® Buffer Ï≤òÎ¶¨ Ïò§Î•ò:", error);
            }
          }
          isBufferProcessing[index] = false;
        }, 50);
      }
    };

    mse.addEventListener("sourceopen", () => {
      ws.onmessage = (event) => {
        const data = new Uint8Array(event.data);

        if (data[0] === 9) {
          const decodedArr = data.slice(1);
          const mimeCodec = new TextDecoder("utf-8").decode(decodedArr);

          try {
            if (!mseSourceBuffer) {
              mseSourceBuffer = mse.addSourceBuffer(
                `video/mp4; codecs="${mimeCodec}"`
              );
              mseSourceBuffer.mode = "segments";

              mseSourceBuffer.addEventListener("updateend", () => {
                if (
                  pendingBuffers[index].length > 0 &&
                  !mseSourceBuffer.updating
                ) {
                  try {
                    mseSourceBuffer.appendBuffer(pendingBuffers[index].shift());
                  } catch (error) {
                    console.error("üö® Failed to append pending buffer:", error);
                  }
                }
              });

              while (pendingBuffers[index].length > 0) {
                if (!mseSourceBuffer.updating) {
                  mseSourceBuffer.appendBuffer(pendingBuffers[index].shift());
                }
              }
            }
          } catch (error) {
            console.error("üö® Failed to initialize SourceBuffer:", error);
          }
        } else if (mseSourceBuffer) {
          if (!mseSourceBuffer.updating) {
            try {
              mseSourceBuffer.appendBuffer(event.data);
            } catch (error) {
              console.error("üö® Failed to append buffer:", error);
            }
          } else {
            pendingBuffers[index].push(event.data);
          }
        }
      };
    });

    ws.onclose = () => {
      console.log(`‚ùå WebSocket disconnected: ${wsUrl}`);
      if (mse.readyState === "open") {
        try {
          mse.endOfStream();
        } catch (error) {
          console.error("üö® Failed to close MediaSource:", error);
        }
      }
    };

    ws.onerror = (error) => console.error(`üö® WebSocket error:`, error);
  };

  const stopStreamAsync = (index) => {
    return new Promise((resolve) => {
      if (!window[`ws_${index}`]) {
        console.warn(`‚ö†Ô∏è No WebSocket found for index ${index}, skipping.`);
        resolve();
        return;
      }

      console.log(`‚ùå Closing WebSocket for index ${index}...`);

      try {
        const ws = window[`ws_${index}`];

        ws.onclose = () => {
          console.log(`‚úÖ WebSocket closed for index ${index}`);
          delete window[`ws_${index}`];
          setTimeout(resolve, 300); // Îã´Ìûå ÌõÑ ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥ Ï∂îÍ∞Ä (ÏïàÏ†ïÏÑ± ÌôïÎ≥¥)
        };

        ws.onerror = (error) => {
          console.error(
            `üö® WebSocket error while closing: index ${index}`,
            error
          );
          delete window[`ws_${index}`];
          setTimeout(resolve, 300);
        };

        ws.close();
      } catch (error) {
        console.error(`üö® Error closing WebSocket for index ${index}:`, error);
        setTimeout(resolve, 300);
      }
    });
  };

  const cleanUpWebSockets = () => {
    const activeConnections = Object.keys(window).filter((key) =>
      key.startsWith("ws_")
    );

    if (activeConnections.length > MAX_CONNECTIONS) {
      const oldestIndex = activeConnections[0].split("_")[1];
      stopStreamAsync(oldestIndex);
    }
  };
  setInterval(cleanUpWebSockets, MAX_SESSION_DURATION);

  return (
    <div className="dashboard">
      <div className="wrapper">
        <div className="layout_column">
          <div className="logobox">
            <div className="logo_wrapper">
              <img src={logo} alt="logo" />
              <span>Ïä§ÎßàÌä∏ÏïàÏ†ÑÍ¥ÄÎ¶¨ÏãúÏä§ÌÖú</span>
              {/* top menu ÏóêÏÑú ÎåÄÏãúÎ≥¥Îìú ÏÑ†ÌÉùÌï†Îïå Î≥¥Í≥†ÏûàÎçò ÌòÑÏû•Ïù¥ ÎßûÎäîÏßÄ Ï≤¥ÌÅ¨ÌïòÍ∏∞ ÏúÑÌïòÏó¨ */}
              {/* <span>{selectedWorkplaceId}</span> */}
            </div>
          </div>
          <div className="box box_safety">
            <div className="titlebox center big title_safety">AI ÏïàÏ†ÑÍ∞êÏãú</div>
            <div className="innerbox">
              <div className="aicircle">
                <div className="aicircle inner">
                  <div className="backlight"></div>
                  <CustomIcon name="ai" />
                </div>
              </div>
              <div className="colgroup">
                <div className="col">
                  <div className="amount">-</div>
                  <div className="name">ÏïàÏ†ÑÎ™®ÎØ∏Ï∞©Ïö©</div>
                </div>
                <div className="sepa"></div>
                <div className="col">
                  <div className="amount">-</div>
                  <div className="name">ÌôîÏû¨ÏúÑÌóò</div>
                </div>
                <div className="sepa"></div>
                <div className="col">
                  <div className="amount">-</div>
                  <div className="name">Í∞úÍµ¨Î∂ÄÏ†ëÍ∑º</div>
                </div>
                <div className="sepa"></div>
                <div className="col">
                  <div className="amount">-</div>
                  <div className="name">ÏûëÏóÖÏûêÏì∞Îü¨Ïßê</div>
                </div>
                <div className="sepa"></div>
                <div className="col">
                  <div className="amount">-</div>
                  <div className="name">Ï§ëÏû•ÎπÑÏ†ëÍ∑º</div>
                </div>
              </div>
            </div>
          </div>
          <div className="box">
            {/* Í≥µÏ†ïÎ•†Ïóê ÎåÄÌïúÍ±¥ Ïñ¥ÎñªÍ≤å ÎøåÎ¶¨ÎùºÎäîÍ±∞ÏßÄ..? (ÌòúÏßÑ) */}
            {/* <div className="titlebox">
              <div className="title">Í≥µÏ†ïÎ•†</div>
              <div className="btns">
                <button>Í∞ÄÏÑ§ÏàòÏßÅÍµ¨ 1#</button>
                <button className="on">Í∞ÄÏÑ§ÏàòÏßÅÍµ¨ 2#</button>
              </div>
            </div>
            <div className="innerbox progress">
              <div className="progressbox">
                <div className="percent">22.25%</div>
                <div className="bar">
                  <div className="bar_background">
                    <div
                      className="bar_foreground"
                      style={{ width: "22.25%" }}
                    ></div>
                  </div>
                </div>
                <div className="detail">
                  ÎàÑÏ†Å: 52m / Í≥ÑÌöç: 2,314m / ÍπäÏù¥: 47m
                </div>
              </div>
            </div> */}
            <div className="titlebox smallbox">
              <div className="title">Ï∂úÏûÖÌòÑÌô©</div>
            </div>
            <div className="innerbox row">
              {/* Í≤åÏù¥Ìä∏ Ïù¥ÎØ∏ÏßÄ Í≥†Ï†ïÌïòÎäîÍ±¥Í∞Ä?
                ÌòÑÏû•ÎßàÎã§ ÏÜåÏÜçÏùÄ Ï†úÍ∞ÅÍ∞ÅÏù∏Îç∞ Ïä§ÌÉÄÏùºÏù¥ Í≥†Ï†ïÎêòÏñ¥ÏûàÏùå (ÌòúÏßÑ) */}
              <div className="column img">
                <img src={t300} alt="gate" />
              </div>

              {/* Í∑∏Î£πÎ≥Ñ Ïª¨Îüº Î∞òÎ≥µ */}
              {columns.map((chunk, idx) => (
                <div className="column flexstart" key={idx}>
                  <div className="visitbox">
                    <div className="type">
                      {chunk.map((g) => (
                        <span key={g.name}>
                          {g.name.length > 5
                            ? g.name.slice(0, 4) + "‚Ä¶"
                            : g.name}
                        </span>
                      ))}
                    </div>

                    <div className="number">
                      {chunk.map((g) => (
                        <span key={g.name}>{g.count}</span>
                      ))}
                    </div>
                  </div>
                </div>
              ))}

              {/* Ï¥ù Î∞©Î¨∏ / ÏûîÎ•ò */}
              <div className="column">
                <div className="visitbox">
                  <div className="type">
                    <div>
                      <IonIcon name="IoStatsChart" color="#299F40" />
                      <span>Ï¥ùÎ∞©Î¨∏</span>
                    </div>
                    <div>
                      <IonIcon name="IoPerson" color="#299F40" />
                      <span>ÏûîÎ•òÏ§ë</span>
                    </div>
                  </div>
                  <div className="number total">
                    <span>{totalVisit}Î™Ö</span>
                    <span>{totalStay}Î™Ö</span>
                  </div>
                </div>
              </div>
            </div>
            <div className="titlebox smallbox">
              <div className="title">Ï∂úÏûÖÎÇ¥Ïó≠</div>
            </div>
            <div className="tablebox">
              <table>
                <colgroup>
                  <col style={{ width: "27%" }} />
                  <col />
                  <col style={{ width: "10%" }} />
                  <col style={{ width: "32%" }} />
                </colgroup>
                <thead>
                  <tr>
                    <th className="alignleft">ÏùºÏãú</th>
                    <th>ÏÜåÏÜç</th>
                    <th>Ïù¥Î¶Ñ</th>
                    <th>Ï∂úÏûÖÏû•Ïπò</th>
                  </tr>
                </thead>
                <tbody>
                  {rows.map((row, idx) => (
                    <tr key={idx}>
                      {row /* Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏûàÏùÑ Îïå */ ? (
                        <>
                          <td className="alignleft">{row.date}</td>
                          <td>{row.department}</td>
                          <td>{row.name}</td>
                          <td>{row.device}</td>
                        </>
                      ) : (
                        /* Îπà Ïπ∏ Ìå®Îî© Ìñâ */
                        <>
                          <td className="alignleft">&nbsp;</td>
                          <td>&nbsp;</td>
                          <td>&nbsp;</td>
                          <td>&nbsp;</td>
                        </>
                      )}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div className="layout_column center">
          <div className="box top">
            <div className="pie">
              <div className="state">
                <div className="backlight"></div>
                <div className="title">ÌòÑÏû•ÏïàÏ†ÑÏßÄÏàò</div>
                {/* <div className="stat color1">Ï†ïÏÉÅ</div> */}
                <div className="stat color1">-</div>
              </div>
              <div
                className="donut"
                style={{
                  "--first": 0.2,
                  "--second": 0.2,
                  "--third": 0.2,
                  "--fourth": 0.2,
                  "--fifth": 0.2,
                }}
              >
                <div className="donut__slice donut__slice__first"></div>
                <div className="donut__slice donut__slice__second"></div>
                <div className="donut__slice donut__slice__third"></div>
                <div className="donut__slice donut__slice__fourth"></div>
                <div className="donut__slice donut__slice__fifth"></div>
              </div>
              <div
                className="donut blur"
                style={{
                  "--first": 0.2,
                  "--second": 0.2,
                  "--third": 0.2,
                  "--fourth": 0.2,
                  "--fifth": 0.2,
                }}
              >
                <div className="donut__slice donut__slice__first"></div>
                <div className="donut__slice donut__slice__second"></div>
                <div className="donut__slice donut__slice__third"></div>
                <div className="donut__slice donut__slice__fourth"></div>
                <div className="donut__slice donut__slice__fifth"></div>
              </div>
            </div>
            <div className="legends">
              <div className="legend">
                <div className="bullet"></div>
                <div className="text">Ï†ïÏÉÅ</div>
              </div>
              <div className="legend">
                <div className="bullet"></div>
                <div className="text">Ï†êÍ≤Ä</div>
              </div>
              <div className="legend">
                <div className="bullet"></div>
                <div className="text">Ï£ºÏùò</div>
              </div>
              <div className="legend">
                <div className="bullet"></div>
                <div className="text">ÏúÑÌóò</div>
              </div>
              <div className="legend">
                <div className="bullet"></div>
                <div className="text">ÌôîÏû¨</div>
              </div>
            </div>
          </div>
          <div className="box tran"></div>
        </div>
        <div className="layout_column">
          <div className="watchbox">
            <div className="date">{fDate}</div>
            <div className="time">{fTime}</div>
            <button onClick={handleClose} className="closebtn">
              <IonIcon name="IoClose" />
            </button>
          </div>
          <div className="box">
            <div className="titlebox title_cctv">
              <div className="btns">
                <button className="greybtn">
                  {/* Real-time AI Camera Monitoring */}
                  Real-time Camera Monitoring
                </button>
              </div>
              {/* ÎèãÎ≥¥Í∏∞ Î¨¥Ïä®ÏùòÎØ∏Ïù¥ÏßÄ ? (ÌòúÏßÑ) */}
              {/* <div className="btns right">
                <a>
                  <IonIcon name="IoSearch" size="small" />
                </a>
              </div> */}
            </div>
            <div className="cctvbox">
              {cameraList.length === 0 ? (
                /* Ïπ¥Î©îÎùºÍ∞Ä ÌïòÎÇòÎèÑ ÏóÜÏùÑ Îïå */
                <div>Ïπ¥Î©îÎùº Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.</div>
              ) : (
                /* Ïπ¥Î©îÎùºÍ∞Ä ÏûàÏùÑ Îïå */
                cameraList.map((cam, idx) => (
                  <div className="wrapper videobox" key={cam.camUUID ?? idx}>
                    <video
                      id={`mse-video-${idx}`}
                      className="video"
                      autoPlay
                      muted
                      playsInline
                    />
                    <div className="title">{cam.cameraName}</div>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DashBoard;
